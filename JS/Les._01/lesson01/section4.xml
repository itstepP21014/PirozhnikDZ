<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №1: Введение в JavaScript" next="section5.xml" prev="section3.xml" summ="0">
<h2>Операторы</h2>
<p>Как уже было сказано ранее, переменные и литералы играют значительную роль в программировании. Однако, сама по себе переменная не выполняет никаких действий. Для этой цели в любом (почти) языке программирования используются <strong>операторы</strong>.
</p>

<p>Операторы позволяют связывать данные различного рода отношениями (математическими, логическими и т.п.) и составлять <strong>выражения</strong>. Именно операторы выполняют действия над данными, хранимыми в переменных или задаваемых литералами. Данные, над которыми выполняются действия, называются <strong>операндами</strong>. Операторы классифицируются по количеству участвующих в отношении операндов следующим образом:
</p>

<ul>
	<li>унарные (одноместные) - один операнд;</li>
	<li>бинарные (двухместные) - два операнда;</li>
	<li>тернарные (трехместные) - три операнда;</li>
	<li>и т.д.</li>	
</ul>
<tip start="Примечание">Наиболее распространенными являются бинарные операторы, немного реже встречаются унарные. В JavaScript, как и в C++, реализован один единственный тернарный оператор - "?:" (см. ниже). Операторы с более высокой "арностью" (кол-вом операндов) не встречаются ни в одном из современных популярных языков программирования.
</tip>

<p>Существует несколько форм записи операторов: 
</p>
<ul>
	<li>префиксная,</li>
	<li>постфиксная,</li>
	<li>инфиксная.</li>
</ul>

<p>Каждая форма записи определяет порядок следования операндов по отношению к знаку операции. Ниже на примере бинарного оператора арифметического сложения показаны различные формы записи операторов:
</p>

<example>
+ операнд1 операнд2  <comment>//префиксная запись</comment>&#160;
операнд1 операнд2 +  <comment>//постфиксная запись</comment>&#160;
операнд1 + операнд2  <comment>//инфиксная (традиционная) запись</comment>&#160;
</example>

<p>В JavaScript для бинарных и единственного тернарного операторов используется исключительно инфиксная форма записи. В отношении унарных операторов политика более гибкая - в JavaScript используется как префиксная, так и постфиксная формы записи унарных операторов.
</p>

<h3>Арифметические операторы</h3>
<p>Данная группа операторов позволяет связывать два числовых значения математическим отношением. В качестве операндов могут выступать как числовые литералы, так и переменные числового типа, а, так же, значения, возвращаемые функциями.
</p>


<p>Ниже представлен перечень арифметических операторов, поддерживаемых JavaScript:
</p>

<table align="center" border="1" cellspacing="0" frame="box" rules="groups" style="margin-bottom: 10;">
	<tr>
		<th>Оператор</th>
		<th>Название</th>
		<th>Пример</th>
		<th>Результат</th>
	</tr>
	<caption align="center" valign="bottom">Табл. 1.2. Арифметические операторы JavaScript</caption>
	
	<colgroup style="width: 80; padding-left: 10;" />
	<colgroup style="width: 300; padding-left: 10;" />
	<colgroup style="width: 80; padding-left: 10;" />
	<colgroup style="width: 80; padding-right: 10; text-align:right;" />

	<tr>
		<td>+</td><td>Сложение</td><td><code><num>10</num>+<num>3</num></code></td><td><code><num>13</num></code></td>
	</tr>
	<tr>
		<td>-</td><td>Вычитание</td><td><code><num>10</num>-<num>3</num></code></td><td><code><num>7</num></code></td>
	</tr>
	<tr>
		<td>-</td><td>Унарный минус (обратная величина)</td><td><code>-<num>10</num></code></td><td><code><num>-10</num></code></td>
	</tr>
	<tr>
		<td>*</td><td>Умножение</td><td><code><num>10</num>*<num>3</num></code></td><td><code><num>30</num></code></td>
	</tr>
	<tr>
		<td>/</td><td>Деление</td><td><code><num>30</num>/<num>3</num></code></td><td><code><num>10</num></code></td>
	</tr>
	<tr>
		<td>%</td><td>Остаток от деления</td><td><code><num>10</num>%<num>3</num></code></td><td><code><num>1</num></code></td>
	</tr>

</table>

<p>Теперь попробуем применить арифметические операторы и составить простое арифметическое выражение. Например - найдем среднее арифметическое двух чисел. Как известно, средним арифметическим нескольких чисел называется сумма чисел, деленная на их количество. С учетом данного правила напишем скрипт:
</p>
<example number="1.4" title="среднее арифметическое чисел" href="samples/average.html">
<keyword>var</keyword> average = (<num>10</num>+<num>12</num>)/<num>2</num>; <comment>// среднее арифметическое чисел 10 и 12</comment>&#160;
<stdfunc>alert</stdfunc> (average);
</example>

<p>Результатом будет число 11. В приведенном выше выражении присутствует оператор "()" - круглые скобки. Круглые скобки в выражениях используются для нарушения традиционного приоритета операторов. Вам, безусловно, известно, что операция деления ("/") выполняется раньше, чем операция суммирования ("+"). Поэтому, если записать предыдущее выражение без скобок, результат будет совершенно другим:
</p>
<example number="1.5" title="среднее арифметическое чисел (неверный пример)" href="samples/average_bad.html">
<keyword>var</keyword> average = <num>10</num>+<num>12</num>/<num>2</num>; <comment>// не используем скобки</comment>&#160;
<stdfunc>alert</stdfunc> (average);
</example>

<p>В результате получим число 16, так как сначала число 12 будет поделено на 2 (получим 6), а, затем результат будет просуммирован с числом 10 (получим 16). О приоритете операций мы с вами подробнее побеседуем в конце данного раздела урока.
</p>

<h3>Конкатенация строк</h3>
<p>В JavaScript оператор "+" используется не только для составления арифметических выражений. Если применить этот оператор для связи двух строковых операндов, то в результате получится строка, состоящая из сцепления первого и второго операнда последовательно. Такая операция в программировании называется "<strong>конкатенация</strong>". Рассмотрим пример:
</p>
<example>
<kw>var</kw> name=<str>"Вася"</str>;
<stdfunc>alert</stdfunc> (<str>"Привет, "</str>+name+<str>"!"</str>);
</example>

<p>В результате пользователь получит сообщение <code><str>"Привет, Вася!"</str></code>. 
</p>

<p>Если в конкатенации используются только строковые операнды, то все предельно просто. Однако, при конкатенации строковых и нестроковых значений JavaScript, сначала, преобразует нестроковое значение в строку и выполнит конкатенацию. Происходит это следующим образом:
</p>
<ul>
<li>При попытке выполнить конкатенацию строки и числа, JavaScript преобразует число в строку (не наоборот!!!) и выполнит конкатенацию:

<example>
<kw>var</kw> str=<str>"10"</str>;
<stdfunc>alert</stdfunc> (str+<num>5</num>); <comment>// результат - строка "105"</comment>
</example>
</li>

<li>При выполнении конкатенации строки и логического значения, JavaScript преобразует логическое значение в строку (<code><kw>false</kw></code> - в строку <code><str>"false"</str></code>, <code><kw>true</kw></code> - в строку <code><str>"true"</str></code>) и выполнит конкатенацию:
<example>
<kw>var</kw> bool1=<kw>true</kw>;
<stdfunc>alert</stdfunc> (<str>"bool1 = "</str>+bool1); <comment>// результат - строка "bool1 = true"</comment>
</example>
</li>
</ul>

<p>Конкатенация строк - очень полезная операция, однако и бед она тоже может принести немало при невнимательном использовании. Поэтому строго контролируйте типы данных и последовательность выполнения операций, при построении выражений, содержащих разнотипные данные. Следующий пример показывает ошибочное выражение с конкатенацией строк:
</p>

<example>
<kw>var</kw> a=10; 
<kw>var</kw> b=5;
<stdfunc>alert</stdfunc> (<str>"Сумма "</str>+a+<str>"+"</str>+b+<str>" = "</str>+a+b);
</example>

<p>Ожидаемый результат - сообщение с текстом <code><str>"Сумма 10+5 = 15"</str></code>, однако, ответ будет другим! Все дело в том, что и конкатенация строк, и арифметическое сложение имеют одинаковый приоритет, и, следовательно, выражение будет вычисляться последовательно слева направо по правилам конкатенации, описанным выше. Сначала к строке <code><str>"Сумма "</str></code> будет присоединено значение переменной "a", преобразованное в строку (<code><str>"10"</str></code>), затем строка <code><str>"+"</str></code> и т.д. Результат будет таким: <code><str>"Сумма 10+5 = 105"</str></code>. 
</p>

<p>Чтобы пример работал корректно, необходимо использовать круглые скобки для нарушения приоритета операций:
</p>
<example>
<kw>var</kw> a=10; 
<kw>var</kw> b=5;
<stdfunc>alert</stdfunc> (<str>"Сумма "</str>+a+<str>"+"</str>+b+<str>" = "</str>+<highlight>(a+b)</highlight>);
</example>

<h3>Операторы инкремента и декремента</h3>
<p>Оба этих оператора унарные. Оператор инкремента используется для увеличения значения операнда на единицу. Оператор декремента выполняет обратное действие - уменьшение значения операнда на единицу. Ниже представлены эти операторы:
</p>
<table align="center" border="1" cellspacing="0" frame="box" rules="groups" style="margin-bottom: 10;">
	<tr>
		<th>Оператор</th>
		<th>Название</th>
	</tr>
	<caption align="center" valign="bottom">Табл. 1.3. Инкремент и декремент</caption>
	
	<colgroup style="width: 80; padding-left: 10;" />
	<colgroup style="width: 200; padding-left: 10;" />

	<tr>
		<td>++</td><td>Инкремент</td>
	</tr>
	<tr>
		<td>--</td><td>Декремент</td>
	</tr>
</table>


<p>В JavaScript реализованы как префиксная, так и постфиксная формы записи операторов инкремента и декремента. Обе формы записи эквивалентны, если используются самостоятельно, вне выражения. Например - так:
</p>

<example>
<keyword>var</keyword> a=0;
++a; <comment>//a=1</comment>
a--; <comment>//a=0</comment>
</example>

<p>Однако, при использовании операторов инкремента и декремента в выражениях, форма записи имеет огромное значение. Рассмотрим, к примеру, следующие выражения:
</p>
<example>
<keyword>var</keyword> x1=1, x2=1;
<keyword>var</keyword> result1=10-x1++; <comment>//result1=9, x1=2; </comment>&#160;
<keyword>var</keyword> result2=10-++x2; <comment>//x2=2, result2=8; </comment>
</example>

<p>В первом случае, когда используется постфиксная форма записи оператора инкремента, значение переменной "result1" будет равно 9, так как инкремент выполнится после вычисления выражения на основании текущего значения переменной "x". Во втором случае значение переменной "result2" будет равно 8, так как сначала выполняется инкремент (значение переменной "x" увеличится на единицу и будет равно "2"), а, затем, будет вычислено значение выражения.
</p>


<h3>Операторы сравнения</h3>
<p>Данный вид операторов позволяет выполнить сравнение двух величин и получить результат сравнения - логическое значение ("истина" или "ложь"). Ниже перечислены операторы сравнения, реализованные в JavaScript:
</p>
<table align="center" border="1" cellspacing="0" frame="box" rules="groups" style="margin-bottom: 10;">
	<tr>
		<th>Оператор</th>
		<th>Название</th>
		<th>Пример</th>
		<th>Результат</th>
	</tr>
	<caption align="center" valign="bottom">Табл. 1.4. Операторы сравнения</caption>
	
	<colgroup style="width: 80; padding-left: 10;" />
	<colgroup style="width: 300; padding-left: 10;" />
	<colgroup style="width: 80; padding-left: 10;" />
	<colgroup style="width: 80; padding-right: 10; text-align:center;" />

	<tr>
		<td>&lt;</td><td>Меньше</td><td><code><num>10</num>&lt;<num>3</num></code></td><td><code><keyword>false</keyword></code></td>
	</tr>
	<tr>
		<td>&gt;</td><td>Больше</td><td><code><num>10</num>&gt;<num>3</num></code></td><td><code><keyword>true</keyword></code></td>
	</tr>
	<tr>
		<td>&lt;=</td><td>Меньше либо равно (не больше)</td><td><code><num>10</num>&lt;=<num>10</num></code></td><td><code><keyword>true</keyword></code></td>
	</tr>
	<tr>
		<td>&gt;=</td><td>Больше либо равно (не меньше)</td><td><code><num>10</num>&gt;=<num>10</num></code></td><td><code><keyword>true</keyword></code></td>
	</tr>
	<tr>
		<td>!=</td><td>Не равно</td><td><code><num>10</num>!=<num>3</num></code></td><td><code><keyword>true</keyword></code></td>
	</tr>
	<tr>
		<td>==</td><td>Равно</td><td><code><num>10</num>==<num>10</num></code></td><td><code><keyword>true</keyword></code></td>
	</tr>
	<tr>
		<td>!==</td><td>Строго не равно, идентично</td><td><code><num>10</num>!==<str>"10"</str></code></td><td><code><keyword>true</keyword></code></td>
	</tr>
	<tr>
		<td>===</td><td>Строго равно, не идентично</td><td><code><num>10</num>===<str>"10"</str></code></td><td><code><keyword>false</keyword></code></td>
	</tr>
</table>

<p>При сравнении операндов различных типов данных, JavaScript выполняет автоматическое преобразование типов операндов к числовому типу. Происходит это следующим образом:
</p>
<ul>
	<li>Если один операнд является строкой, а второй - числом, JavaScript попытается преобразовать строку в число. В следующем примере результатом сравнения будет значение <code><kw>true</kw></code>:
<example>
<kw>var</kw> var1 = <str>"10"</str>;
<kw>var</kw> var1 = <num>10</num>;
<kw>var</kw> result = var1==var2;
</example>
	Если строку невозможно преобразовать в число (например - строку <code><str>"Hello!"</str></code>), результатом сравнения будет <code><kw>false</kw></code>.
	</li>
	<li>Если один операнд является числом, а второй - булевым значением, JavaScript попытается преобразовать булево значение в число по следующему правилу: <code><kw>true</kw></code> преобразуется в число 1, <code><kw>false</kw></code> - в число 0. В следующем примере результатом сравнения будет значение <code><kw>true</kw></code>:
<example>
<kw>var</kw> var1 = <kw>true</kw>;
<kw>var</kw> var1 = <num>1</num>;
<kw>var</kw> result = var1==var2;
</example>
	</li>
	<li>Если один операнд является булевым значением, а второй - строкой, JavaScript попытается преобразовать булево значение в число, а, затем - строку в число. В следующем примере результатом сравнения будет значение <code><kw>true</kw></code>:
<example>
<kw>var</kw> var1 = <kw>true</kw>;
<kw>var</kw> var1 = <num>"1"</num>;
<kw>var</kw> result = var1==var2;
</example>	
</li>
</ul>


<p>Стоит особо отметить последние два оператора в приведенном выше списке - операторы "идентично" ("===") и "не идентично" ("!=="). Данные операторы сравнивают не только значения операндов, но  и их типы. Таким образом, если связать два операнда оператором "идентично", то, для получения истинного результата необходимо, чтобы совпадали их значения и операнды принадлежали одному типу данных (или оба числовые, или оба строковые и т.д.). В следующем примере результатом сравнения будет значение <code><kw>false</kw></code>:
</p>
<example>
<kw>var</kw> var1 = <kw>true</kw>;
<kw>var</kw> var1 = <num>1</num>;
<kw>var</kw> result = var1===var2;
</example>


<p>Операторы сравнения используются совместно с логическими операторами в логических выражениях, которые применяются в условиях и циклах.
</p>

<h3>Логические операторы</h3>
<p>Логические операторы используются для связывания логических значений логическим отношением. В JavaScript их всего три:
</p>

<table align="center" border="1" cellspacing="0" frame="box" rules="groups" style="margin-bottom: 10;">
	<tr>
		<th>Оператор</th>
		<th>Название</th>
		<th>Пример</th>
		<th>Результат</th>
	</tr>
	<caption align="center" valign="bottom">Табл. 1.5. Логические операторы</caption>
	
	<colgroup style="width: 80; padding-left: 10;" />
	<colgroup style="width: 300; padding-left: 10;" />
	<colgroup style="width: 120; padding-left: 10;" />
	<colgroup style="width: 80; padding-right: 10; text-align:center;" />

	<tr>
		<td>&amp;&amp;</td><td>Логическая операция "И" - AND</td><td><code><keyword>true</keyword> &amp;&amp; <keyword>false</keyword></code></td><td><code><keyword>false</keyword></code></td>
	</tr>
	<tr>
		<td>||</td><td>Логическая операция "ИЛИ" - OR</td><td><code><keyword>true</keyword> || <keyword>false</keyword></code></td><td><code><keyword>true</keyword></code></td>
	</tr>
	<tr>
		<td>!</td><td>Логическая операция "НЕ" - NOT</td><td><code>!<keyword>true</keyword></code></td><td><code><keyword>false</keyword></code></td>
	</tr>
</table>

<p>Оператор AND возвращает "истину" только в тех случаях, когда оба операнда имеют значение "истина". Оператор OR возвращает "ложь" только в тех случаях, когда оба операнда имеют значение "ложь". Оператор NOT возвращает обратное логическое значение операнда - если операнд имеет значение "истина", оператор возвращает "ложь" и наоборот.
</p>
<p>В JavaScript значению "ложь" соответствует не только логический литерал <code><kw>false</kw></code>, но и несколько эквивалентов других типов данных: 
</p>
<ul>
<li><code><num>0</num></code>,</li>
<li><code><str>""</str></code>,</li>
<li><code><kw>null</kw></code>,</li>
<li><code><resword>undefined</resword></code></li>
</ul>

<p>Все остальные значения считаются эквивалентом "истины" - <code><kw>true</kw></code>. Таким образом, в логических выражениях могут участвовать значения не булевого типа. 
</p>


<h3>Побитовые операторы</h3>
<p>Если предыдущие операторы действовали над значениями операндов, то операторы данной группы действуют над битами своих операндов. Для понимания побитовых операторов необходимо свободно уметь работать с двоичным представлением чисел. Если это не так, остается только надеяться, что данные операторы не часто вам будут попадаться в вашей практике. Ниже следует перечень побитовых операторов с примерами их применения (примеры и результаты даны, так же, и в бинарной (двоичной) форме):
</p>

<table align="center" border="1" cellspacing="0" frame="box" rules="groups" style="margin-bottom: 10;">
	<tr>
		<th>Оператор</th>
		<th>Название</th>
		<th>Пример</th>
		<th>Бин.</th>
		<th>Результат</th>
		<th>Бин.</th>
	</tr>
	<caption align="center" valign="bottom">Табл. 1.6. Побитовые операторы</caption>
	
	<colgroup style="width: 80; padding-left: 10;" />
	<colgroup style="width: 310; padding-left: 10;" />
	<colgroup style="width: 60; padding-left: 10;" />
	<colgroup style="width: 100; padding-left: 10;" />
	<colgroup style="width: 80; padding-right: 10; text-align:center;" />
	<colgroup style="width: 60; padding-right: 10; text-align:center;" />

	<tr>
		<td>&amp;</td><td>Побитовая операция "И"</td><td><code><num>2</num>&amp;<num>3</num></code></td><td><code><num>0010</num>&amp;<num>0011</num></code></td><td><code><num>2</num></code></td><td><code><num>0010</num></code></td>
	</tr>
	<tr>
		<td>|</td><td>Побитовая операция "ИЛИ"</td><td><code><num>2</num>|<num>3</num></code></td><td><code><num>0010</num>|<num>0011</num></code></td><td><code><num>3</num></code></td><td><code><num>0011</num></code></td>
	</tr>
	<tr>
		<td>~</td><td>Побитовая операция "НЕ"</td><td><code>~<num>3</num></code></td><td><code>~<num>0011</num></code></td><td><code><num>12</num></code></td><td><code><num>1100</num></code></td>
	</tr>
	<tr>
		<td>^</td><td>Побитовая операция "ИСКЛЮЧАЮЩЕЕ ИЛИ"</td><td><code><num>2</num>^<num>3</num></code></td><td><code><num>0010</num>^<num>0011</num></code></td><td><code><num>1</num></code></td><td><code><num>0001</num></code></td>
	</tr>
	<tr>
		<td>&lt;&lt;</td><td>Побитовая операция "сдвиг влево"</td><td><code><num>1</num>&lt;&lt;<num>3</num></code></td><td><code><num>0001</num>&lt;&lt;<num>3</num></code></td><td><code><num>8</num></code></td><td><code><num>1000</num></code></td>
	</tr>
	<tr>
		<td>&gt;&gt;</td><td>Побитовая операция "сдвиг вправо"</td><td><code><num>8</num>&gt;&gt;<num>3</num></code></td><td><code><num>1000</num>&gt;&gt;<num>3</num></code></td><td><code><num>1</num></code></td><td><code><num>0001</num></code></td>
	</tr>
</table>

<p>Принцип работы побитовых операторов достаточно прост: JavaScript рассматривает последовательно каждый бит операндов, выполняет над ними одну из логических операций (исходя из того, что 1 - <code><keyword>true</keyword></code>, a 0 - <code><keyword>false</keyword></code>) и формирует бит результата. Исключением являются лишь операции побитового сдвига. Рассмотрим небольшой пример применения побитовых операций - определение четности числа. Если число является четным, то его первый (крайний правый) бит равен "0" и операция "&amp;" с числом "1" вернет значение "0". Исходя из этого, напишем скрипт:
</p>
<example number="1.6" title="определение четности числа" href="samples/chet_nechet.html">
<kw>var</kw> some_number = <num>105</num>;
<kw>var</kw> result = (some_number &amp; <num>1</num>) == <num>0</num>;
<stdfunc>alert</stdfunc> (result);
</example>

<p>Если в результате получится значение <code><kw>false</kw></code>, то заданное число является нечетным, в противном случае, число является четным. 
</p>

<h3>Условный оператор</h3>
<p>Условный оператор является единственным тернарным оператором JavaScript. Это означает, что для его функционирования необходимо три операнда. Формат записи этого оператора имеет следующий вид:
</p>
<example>
логическое_выражение ? выражение1 : выражение2;
</example>

<p>Действует оператор следующим образом:
</p>
<ul>
	<li>проверяется значение логического выражения;</li>
	<li>если "логическое_выражение" имеет значение <code><kw>true</kw></code> возвращается значение "выражение1";</li>
	<li>в противном случае возвращается значение "выражение2".</li>
</ul>
<p>Применим этот оператор на практике в примере "определение четности числа" для получения более понятного, информативного результата:
</p>
<example number="1.7" title="применение условного оператора" href="samples/conditional.html">
<kw>var</kw> some_number = <num>105</num>;
<kw>var</kw> result = (some_number &amp; <num>1</num>) == <num>0</num>;
<stdfunc>alert</stdfunc> (<highlight>result ? <str>"Число четное"</str> : <str>"Число нечетное"</str></highlight>);
</example>

<p>Переписанный таким образом пример будет возвращать уже не логическое значение, а строку, более понятную рядовому пользователю.
</p>


<h3>Операторы присваивания</h3>
<p>С оператором присваивания (=) мы с вами познакомились в предыдущем разделе урока. При помощи данного оператора выполняется инициализация переменных. Однако, данный оператор используется, так же, для изменения значения переменной в процессе работы сценария. Кроме обычного оператора присваивания, в JavaScript реализовано еще несколько операторов присваивания, которые можно разбить на следующие подгруппы:
</p>
<ul>
	<li>арифметические операторы присваивания;</li>
	<li>побитовые операторы присваивания.</li>
</ul>

<p>Каждый из этих операторов не просто присваивает переменной некоторое значение, но и выполняет определенную операцию (арифметическую или побитовую), используя в качестве первого операнда значение переменной в левой части, а в качестве второго операнда значение выражения в правой части. Следующие две записи абсолютно эквивалентны, при условии, что переменная "var1" инициализирована некоторым числовым значением:
</p>
<example>
var1+=<num>10</num>-<num>2</num>;
var1=var1+<num>10</num>-<num>2</num>;
</example>

<p>Ниже представлен перечень "расширенных" операторов присваивания, поддерживаемых JavaScript:
</p>
<table align="center" border="1" cellspacing="0" frame="box" rules="groups" style="margin-bottom: 10;">
	<tr>
		<th>Оператор</th>
		<th>Пример</th>
		<th>Аналог</th>
	</tr>
	<caption align="center" valign="bottom">Табл. 1.7. Операторы арифметического присваивания JavaScript</caption>
	
	<colgroup style="width: 80; padding-left: 10;" />
	<colgroup style="width: 150; padding-left: 10;" />
	<colgroup style="width: 150; padding-left: 10;" />

	<tr>
		<td>+=</td><td>a += b</td><td>a = a+b</td>
	</tr>
	<tr>
		<td>-=</td><td>a -= b</td><td>a = a-b</td>
	</tr>	
	<tr>
		<td>*=</td><td>a *= b</td><td>a = a*b</td>
	</tr>
	<tr>
		<td>/=</td><td>a /= b</td><td>a = a/b</td>
	</tr>
	<tr>
		<td>%=</td><td>a %= b</td><td>a = a%b</td>
	</tr>

</table>

<table align="center" border="1" cellspacing="0" frame="box" rules="groups" style="margin-bottom: 10;">
	<tr>
		<th>Оператор</th>
		<th>Пример</th>
		<th>Аналог</th>
	</tr>
	<caption align="center" valign="bottom">Табл. 1.8. Операторы побитового присваивания JavaScript</caption>
	
	<colgroup style="width: 80; padding-left: 10;" />
	<colgroup style="width: 150; padding-left: 10;" />
	<colgroup style="width: 150; padding-left: 10;" />

	<tr>
		<td>&amp;=</td><td>a &amp;= b</td><td>a = a&amp;b</td>
	</tr>
	<tr>
		<td>|=</td><td>a |= b</td><td>a = a|b</td>
	</tr>	
	<tr>
		<td>^=</td><td>a ^= b</td><td>a = a/b</td>
	</tr>
	<tr>
		<td>&lt;&lt;=</td><td>a &lt;&lt;= b</td><td>a = a&lt;&lt;b</td>
	</tr>
	<tr>
		<td>&gt;&gt;=</td><td>a &gt;&gt;= b</td><td>a = a&gt;&gt;b</td>
	</tr>
</table>

<p>При использовании расширенных операторов присваивания необходимо помнить, что переменная, которой присваивается значение, должна быть проинициализирована ранее. Например, следующая строка кода сгенерирует ошибку:
</p>
<example>
<kw>var</kw> var1+=10; <comment>// Ошибка использования оператора присваивания!</comment>
</example>

<h3>Приоритет и последовательность выполнения операторов</h3>
<p>Зачастую в скриптах используются простые выражения, содержащие два значения и один оператор. Однако на практике вы столкнетесь и с более сложными выражениями, состоящими из большого количества операндов и операторов. В таких выражениях очень важна последовательность выполнения операторов - вспомните пример вычисления среднего арифметического чисел.
</p>

<p>JavaScript вычисляет выражения, руководствуясь приоритетами операторов, приведенными в таблице ниже:
</p>

<table align="center" border="1" cellspacing="0" frame="box" rules="groups" style="margin-bottom: 10;">
	<tr>
		<th>Оператор</th>
		<th>Название</th>
		<th>Приоритет</th>
		<th>Порядок выч.</th>
	</tr>
	<caption align="center" valign="bottom">Табл. 1.9. Приоритеты операторов</caption>
	
	<colgroup style="width: 100; padding-left: 10;" />
	<colgroup style="width: 250; padding-left: 10;" />
	<colgroup style="width: 80; padding-left: 0; text-align: center;" />
	<colgroup style="width: 120; padding-left: 0; text-align: center;" />
	
<tbody>
	<tr>
		<td>++</td><td>Инкремент</td><td rowspan="5">1</td><td rowspan="5">справа налево</td>
	</tr>	
	<tr>
		<td>--</td><td>Декремент</td>
	</tr>
	<tr>
		<td>-</td><td>Унарный минус</td>
	</tr>
	<tr>
		<td>!</td><td>Логическое "НЕ"</td>
	</tr>
	<tr>
		<td>~</td><td>Побитовое "НЕ"</td>
	</tr>
</tbody>	
<tbody>
	<tr>
		<td>*</td><td>Умножение</td><td rowspan="3">2</td><td rowspan="3">слева направо</td>
	</tr>
	<tr>
		<td>/</td><td>Деление</td>
	</tr>
	<tr>
		<td>%</td><td>Остаток от деления</td>
	</tr>	
</tbody>
<tbody>
	<tr>
		<td>+</td><td>Сложение</td><td rowspan="2">3</td><td rowspan="2">слева направо</td>
	</tr>
	<tr>
		<td>-</td><td>Вычитание</td>
	</tr>	
</tbody>
<tbody>
	<tr>
		<td>&lt;</td><td>Меньше</td><td rowspan="4">4</td><td rowspan="4">слева направо</td>
	</tr>
	<tr>
		<td>&lt;=</td><td>Меньше или равно</td>
	</tr>
	<tr>
		<td>&gt;</td><td>Больше</td>
	</tr>
	<tr>
		<td>&gt;=</td><td>Больше или равно</td>
	</tr>
</tbody>
<tbody>
	<tr>
		<td>==</td><td>Равно</td><td rowspan="4">5</td><td rowspan="4">слева направо</td>
	</tr>
	<tr>
		<td>!=</td><td>Не равно</td>
	</tr>
	<tr>
		<td>===</td><td>Идентично</td>
	</tr>
	<tr>
		<td>!==</td><td>Не идентично</td>
	</tr>
</tbody>
<tbody>
	<tr>
		<td>&amp;</td><td>Побитовое "И"</td><td rowspan="3">6</td><td rowspan="3">слева направо</td>
	</tr>
	<tr>
		<td>|</td><td>Побитовое "ИЛИ"</td>
	</tr>
	<tr>
		<td>^</td><td>Побитовое "ИСКЛ. ИЛИ" (XOR)</td>
	</tr>
</tbody>
<tbody>
	<tr>
		<td>&amp;&amp;</td><td>Логическое "И"</td><td rowspan="2">7</td><td rowspan="2">слева направо</td>
	</tr>
	<tr>
		<td>||</td><td>Логическое "ИЛИ"</td>
	</tr>
</tbody>
<tbody>
	<tr>
		<td>?:</td><td>Условный</td><td>8</td><td></td>
	</tr>
</tbody>
<tbody>
	<tr>
		<td>=</td><td>Присваивание</td><td rowspan="5">9</td><td rowspan="5">справа налево</td>
	</tr>
	<tr>
		<td>+=</td><td></td>
	</tr>
	<tr>
		<td>-=</td><td></td>
	</tr>
	<tr>
		<td>*=</td><td></td>
	</tr>
	<tr>
		<td>и т.д.</td><td></td>
	</tr>
</tbody>
</table>

<p>В приведенной выше таблице приоритет операторов указан цифрами от 1 до 9, причем, чем выше число, тем ниже приоритет оператора. Так операторы в уровнем приоритета "1" выполняются раньше, чем операторы в уровнем приоритета "2" и т.д.
</p>

<p>Кроме приоритетов, для операторов важно еще и такое свойство, как <strong>порядок выполнения</strong> - оно определяет, в каком порядке выполняются операторы с одинаковым уровнем приоритета. Рассмотрим пример:
</p>
<example>
<kw>var</kw> number = <num>5</num>;
number = -++number;
</example>

<p>В результате переменная "number" примет значение "-6", так как сначала выполнится операция инкремента, а, затем, операция "унарный минус". Если бы порядок выполнения был обратным, то мы получили бы несколько иной результат.
</p>

</lesson>
