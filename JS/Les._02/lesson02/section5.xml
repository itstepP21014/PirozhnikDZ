<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №1: Введение в JavaScript" next="section6.xml" prev="section4.xml" summ="0">
<h2>Строки</h2>
<p>Поддержка строк в JavaScript обеспечивается объектом <code>String()</code>. До сих пор мы с вами использовали строки в сценариях выполняя над ними всего лишь одну операцию - объединение строк или конкатенацию. В данном разделе мы усовершенствуем наши навыки работы со строками и существенно расширим набор инструментов для работы со строковыми значениями.
</p>

<h3>Свойства и методы строк</h3>
<p>Ниже в таблице представлены свойства и методы строк, наиболее часто применяемые в сценариях:
</p>

<table align="center" border="1" cellspacing="0" frame="box" rules="groups" style="margin-bottom: 10;">
<thead>
	<tr>
		<th>Свойство</th>
		<th>Пояснение</th>
	</tr>
	<caption align="center" valign="bottom">Табл. 2.2. Свойства и методы строк</caption>
</thead>
	<colgroup style="width: 400; padding-left: 10;" />
	<colgroup style="width: 500; padding-left: 10; padding-bottom: 5;" />
<tbody>
	<tr>
		<td><code><i>string</i>.<b>length</b></code></td>
		<td>Длина (количество символов) строки</td>
	</tr>
	<tr>
		<td><code><i>string</i>.<b>prototype</b></code></td>
		<td>Ссылка на прототип класса объекта. Это свойство позволяет добавлять в объекты новые методы.</td>
	</tr>
</tbody>	
<tbody>
	<tr>
		<th>Метод</th>
		<th>Пояснение</th>
	</tr>
</tbody>	
<tbody>
	<tr>
		<td><code><i>str1</i>.<b>bold</b>()</code></td>
		<td>Выводит содержимое строки полужирным шрифтом так, как будто строка заключена в теги <code>&lt;<tag>b</tag>&gt;&lt;/<tag>b</tag>&gt;</code></td>
	</tr>
	<tr>
		<td><code><i>str1</i>.<b>italics</b>()</code></td>
		<td>Выводит содержимое строки курсивом так, как будто строка заключена в теги <code>&lt;<tag>i</tag>&gt;&lt;/<tag>i</tag>&gt;</code></td>
	</tr>
	<tr>
		<td><code><i>str1</i>.<b>strike</b>()</code></td>
		<td>Выводит содержимое строки перечеркнутым так, как будто строка заключена в теги <code>&lt;<tag>s</tag>&gt;&lt;/<tag>s</tag>&gt;</code></td>
	</tr>
	<tr>
		<td><code><i>str1</i>.<b>big</b>()</code></td>
		<td>Выводит содержимое строки шрифтом на единицу большим, чем текущий так, как будто строка заключена в теги <code>&lt;<tag>big</tag>&gt;&lt;/<tag>big</tag>&gt;</code></td>
	</tr>
	<tr>
		<td><code><i>str1</i>.<b>small</b>()</code></td>
		<td>Выводит содержимое строки шрифтом на единицу меньшим, чем текущий так, как будто строка заключена в теги <code>&lt;<tag>small</tag>&gt;&lt;/<tag>small</tag>&gt;</code></td>
	</tr>
	<tr>
		<td><code><i>str1</i>.<b>sub</b>()</code></td>
		<td>Выводит содержимое строки со смещением вниз относительно базовой линии так, как будто строка заключена в теги <code>&lt;<tag>sub</tag>&gt;&lt;/<tag>sub</tag>&gt;</code></td>
	</tr>
	<tr>
		<td><code><i>str1</i>.<b>sup</b>()</code></td>
		<td>Выводит содержимое строки со смещением вверх относительно базовой линии так, как будто строка заключена в теги <code>&lt;<tag>sup</tag>&gt;&lt;/<tag>sup</tag>&gt;</code></td>
	</tr>
	<tr>
		<td><code><i>str1</i>.<b>fixed</b>()</code></td>
		<td>Выводит содержимое строки моноширным шрифтом так, как будто строка заключена в теги <code>&lt;<tag>tt</tag>&gt;&lt;/<tag>tt</tag>&gt;</code></td>
	</tr>
	<tr>
		<td><code><i>str1</i>.<b>fontSize</b>(<i>size</i>)</code></td>
		<td>Выводит содержимое строки шрифтом указанного размера так, как будто строка заключена в теги <code>&lt;<tag>font</tag>&#160;<attr>size</attr>=<str>"<i>size</i>"</str>&gt;&lt;/<tag>font</tag>&gt;</code></td>
	</tr>
	<tr>
		<td><code><i>str1</i>.<b>fontColor</b>(<i>color</i>)</code></td>
		<td>Выводит содержимое строки шрифтом указанного цвета так, как будто строка заключена в теги <code>&lt;<tag>font</tag>&#160;<attr>color</attr>=<str>"<i>color</i>"</str>&gt;&lt;/<tag>font</tag>&gt;</code></td>
	</tr>
	<tr>
		<td><code><i>str1</i>.<b>link</b>(<i>url</i>)</code></td>
		<td>Возвращает содержимое строки как гиперссылку на указанный ресурс</td>
	</tr>
	<tr>
		<td><code><i>str1</i>.<b>toUpperCase</b>()</code></td>
		<td>Возвращает строку в верхнем регистре</td>
	</tr>
	<tr>
		<td><code><i>str1</i>.<b>toLowerCase</b>()</code></td>
		<td>Возвращает строку в нижнем регистре</td>
	</tr>
</tbody>
<tbody>
	<tr>
		<td><code><i>string</i>&#160;<i>str1</i>.<b>charAt</b>(<i>index</i>)</code></td>
		<td>Возвращает символ строки из указанной позиции</td>
	</tr>
	<tr>
		<td><code><i>number</i>&#160;<i>str1</i>.<b>charCodeAt</b>(<i>index</i>)</code></td>
		<td>Возвращает Unicode - код символа строки из указанной позиции</td>
	</tr>
	<tr>
		<td><code><i>number</i>&#160;<i>str1</i>.<b>indexOf</b>(<i>str2</i>[, <i>start</i>])</code></td>
		<td>Возвращает позицию, с которой начинается первое вхождение подстроки str2 в строку str1. Если указан параметр start, поиск подстроки начинается с указанной позиции. Если подстрока str2 в строке str1 не найдена, метод возвращает -1.</td>
	</tr>
	<tr>
		<td><code><i>number</i>&#160;<i>str1</i>.<b>lastIndexOf</b>(<i>str2</i>[, <i>end</i>)</code></td>
		<td>Возвращает позицию, с которой начинается последнее вхождение подстроки str2 в строку str1. Если указан параметр end, поиск подстроки начинается с указанной позиции. Если подстрока str2 в строке str1 не найдена, метод возвращает -1.</td>
	</tr>
	<tr>
		<td><code><i>string</i>&#160;<i>str1</i>.<b>slice</b>(<i>start</i>[, <i>end</i>])</code></td>
		<td>Возвращает часть строки от позиции start и заканчивая позицией end не включительно. Если параметр end опущен, подстрока продолжается до конца строки.</td>
	</tr>
	<tr>
		<td><code><i>string</i>&#160;<i>str1</i>.<b>substring</b>(<i>start</i>[, <i>end</i>])</code></td>
		<td>Возвращает часть строки от позиции start и заканчивая позицией end не включительно. Если параметр end опущен, подстрока продолжается до конца строки. В качестве начальной позиции выступает меньшее из двух указанных значений, т.е. вызовы substring(0,5) и substring(5,0) эквивалентны.</td>
	</tr>
	<tr>
		<td><code><i>string</i>&#160;<i>str1</i>.<b>substr</b>(<i>start</i>[, <i>length</i>])</code></td>
		<td>Возвращает часть строки указанной длины начиная с позиции start. Если параметр length равен 0 или имеет отрицательное значение, возвращается пустая строка. Если параметр length не указан, подстрока продолжается до конца строки.</td>
	</tr>
	<tr>
		<td><code><i>array</i>&#160;<i>str1</i>.<b>split</b>(<i>seperator</i>[, <i>limit</i>])</code></td>
		<td>Разбивает строку str1 на подстроки, разделяемые в строке указанным разделителем и возвращает массив подстрок. Параметр limit служит для ограничения количества элементов в результирующем массиве</td>
	</tr>
</tbody>
</table>

<tip start="Примечание">в таблицу не вошли несколько методов строк, предназначенных для работы с регулярными выражениями. Что такое регулярные выражения, и какие методы строковых объектов мы не рассмотрели, вы узнаете позже на одном из последующих занятий.
</tip>

<h3>Применение методов форматирующих вывод</h3>
<p>Методы, форматирующие вывод применяются в тех случаях, когда необходимо вывести строку на страницу не просто как текстовый фрагмент, а еще и снабдить ее определенным форматом, то есть вывести строку полужирной, курсивом или заданным цветом текста. Безусловно, можно обойтись и без использования данных функций, однако при этом придется предпринимать дополнительные действия для форматирования вывода. Следует помнить, что функции, форматирующие вывод, <b>не изменяют содержимого строки</b>, они возвращают отформатированную строку.
</p>
<p>Приведем практический пример: необходимо вывести список гиперссылок на поисковые системы, которые хранятся в сценарии в виде массива. Ниже показан один из способов реализации данной задачи:
</p>
<example number="2.7" title="Применение методов форматирования вывода строк" href="samples/strformat1.html">
<kw>var</kw> titles = <kw>new</kw> Array(<str>"Rambler"</str>, <str>"Yandex"</str>, <str>"Google"</str>, <str>"Altavista"</str>);
<kw>var</kw> urls   = <kw>new</kw> Array(<str>"http://www.rambler.ru"</str>, <str>"http://www.ya.ru"</str>, 
             <str>"http://www.google.com"</str>, <str>"http://www.altavista.com"</str>);

<kw>for</kw> (<kw>var</kw> i=0; i&lt;titles.length; i++) {
    document.write (titles[i].bold()+<str>": "</str>+urls[i].link(urls[i])+<str>"&lt;br /&gt;"</str>);
}
</example>
<p>Приведенный выше фрагмент кода сначала выводит полужирным начертанием название поискового сервера (элементы массива "titles" - заголовки), а, затем, саму гиперссылку из массива "urls", причем, текст гиперссылки и адрес ресурса совпадают.
</p>
<p>Для сравнения, ниже приводится строка вывода на страницу без использования вышеописанных методов:
</p>
<example>
document.write (<str>"&lt;b&gt;"</str>+titles[i]+<str>"&lt;/b&gt;: &lt;a href='"</str>+urls[i]+<str>"'&gt;"</str>+urls[i]+<str>"&lt;/a&gt;&lt;br /&gt;"</str>);
</example>
<h3>Применение методов <code>indexOf()</code> и <code>lastIndexOf()</code></h3>
<p>Методы <code>indexOf()</code> и <code>lastIndexOf()</code> применяются в тех ситуациях, когда необходимо проверить, является ли некоторая последовательность символов частью строки. Такая необходимость может возникнуть, например, при проверке достоверности данных, введенных пользователем. Приведем простой пример: от пользователя требуется ввести адрес электронной почты а сценарий должен проверить корректность ввода (упрощенно):
</p>
<example number="2.8" title="Пример применения метода 'indexOf()'" href="samples/indexOf.html">
<kw>var</kw> email;
<kw>do</kw> {
    email = <stdfunc>prompt</stdfunc> (<str>"Введите свой e-mail:"</str>,<str>""</str>)
    <kw>if</kw> (<highlight>email.indexOf(<str>"@"</str>) == <num>-1</num></highlight>) {
        <stdfunc>alert</stdfunc> (<str>"Введенный e-mail синтаксически некорректен!\nПовторите операцию."</str>);
    }
    <kw>else</kw>&#160;
        <kw>break</kw>;
} <kw>while</kw> (<kw>true</kw>);
<stdfunc>aler</stdfunc>t (<str>"Спасибо за сотрудничество!"</str>);
</example>
<p>Сценарий в бесконечном цикле запрашивает у пользователя ввод e-mail адреса и проверяет наличие в нем символа "@". Если таковой отсутствует, метод <code>indexOf("@")</code> вернет значение -1 и пользователь получит сообщение об ошибке, после чего запрос повторится. Цикл будет продолжаться до тех пор, пока пользователь не введет строку, содержащую символ "@".
</p>
<p>Совершенно очевидно, что проверка корректности адреса, введенного пользователем, не претендует на полноту и ее запросто можно обойти, введя при запросе символ "@".
</p>
<p>Еще один пример демонстрирует применение метода <code>indexOf()</code> с параметром "start". Пример позволяет вычислить вероятность появления некоторого символа (например - 'а') в произвольном тексте:
</p>
<example>
<kw>var</kw> text=<str>"Карл у Клары украл кораллы, Клара у Карла украла кларнет."</str>;
<kw>var</kw> count=<num>0</num>, start=<num>0</num>;
<kw>do</kw> {
    start=text.indexOf(<str>"а"</str>, start);
    <kw>if</kw> (start > <num>0</num>) 
        count++;
} <kw>while</kw> (start > <num>0</num>);
<stdfunc>aler</stdfunc>t (<str>"Символ 'а' всречается в строке с вероятностью "</str>+count/text.length*<num>100</num>+<str>"%"</str>);
</example>



<h3>Применение методов <code>slice()</code>, <code>substring()</code> и <code>substr()</code></h3>
<p>Все три метода, как следует из таблицы, служат для получения части строки. Эти методы так же можно применить при проверке данных. Например, из адреса электронной почты пользователя необходимо выделить в отдельные строки логин пользователя (символы, находящиеся перед символом "@") и адрес почтового сервера (символы, находящиеся после символа "@") с целью их дальнейшей проверки. Упрощая ситуацию, проверим наличие "." в адресе почтового сервера и отсутствие "." в логине пользователя:
</p>
<example number="2.9" title="Получение подстроки" href="samples/substring.html">
<kw>var</kw> email;
<kw>do</kw> {
    email = <stdfunc>prompt</stdfunc> (<str>"Введите свой e-mail:"</str>,<str>"username@host.com"</str>)
    <kw>var</kw> pos1 = email.indexOf(<str>"@"</str>);
    <kw>if</kw> (pos1 == <num>-1</num>) {
        <stdfunc>alert</stdfunc> (<str>"Введенный e-mail синтаксически некорректен!\nПовторите операцию."</str>);    
    }
    <kw>else</kw> {
        <kw>var</kw> userName = <highlight>email.substring(<num>0</num>, pos1);</highlight>&#160;
        <kw>var</kw> host = <highlight>email.slice(pos1+<num>1</num>);</highlight>&#160;
        
        <kw>if</kw> (userName.indexOf(<str>"."</str>) != <num>-1</num>) 
            <stdfunc>alert</stdfunc> (<str>"Введенный e-mail синтаксически некорректен!\nПовторите операцию."</str>);
        <kw>else</kw>&#160;<kw>if</kw> (host.indexOf(<str>"."</str>) == <num>-1</num>)
            <stdfunc>alert</stdfunc> (<str>"Введенный e-mail синтаксически некорректен!\nПовторите операцию."</str>);
        <kw>else</kw>&#160;
            <kw>break</kw>;	
    }    
} <kw>while</kw> (<kw>true</kw>);
<stdfunc>aler</stdfunc>t (<str>"Спасибо за сотрудничество!"</str>);
</example>

<p>После такой доработки проверка стала значительно лучше, хотя она все еще не универсальна. Теперь пользователь должен вводить символы до "@" без точек, а символы после "@" обязательно должны содержать хотя бы одну точку.
</p>

<h3>Применение метода <code>split()</code></h3>
<p>Метод <code>split()</code> можно с успехом применять для ввода массивов с клавиатуры. Ниже на примере демонстрируется одна из возможных реализаций этого подхода:
</p>
<example number="2.10" title="Применение метода 'split()'" href="samples/split.html">
<kw>var</kw> s = <stdfunc>prompt</stdfunc> (<str>"Введите несколько числовых значений, разделенных запятыми:"</str>, <str>"1,2,5,0,3,7"</str>);
<kw>var</kw> a = s.split(<str>","</str>);
<kw>var</kw> sum=<num>0</num>;
<kw>for</kw> (<kw>var</kw> i=<num>0</num>; i&lt;a.length; i++)
    sum+=<stdfunc>parseInt</stdfunc>(a[i]);
    
<stdfunc>alert</stdfunc> (<str>"Сумма элементов введенного массива: "</str>+sum);
</example>

<p>О функции <code>split()</code> необходимо сказать то, что она поддерживает регулярные выражения, к изучению которых мы вскоре приступим. Это означает, что вместо фиксированной строки-разделителя (например - ",") можно использовать <i>шаблон</i>, <i>маску</i> разделителя. В последнем случае сценарий станет намного эффективнее и универсальнее.
</p>
</lesson>