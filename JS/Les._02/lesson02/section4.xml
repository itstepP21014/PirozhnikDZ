<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="Урок №1: Введение в JavaScript" next="section5.xml" prev="section3.xml" summ="0">
<h2>Массивы</h2>

<p>Массивы в JavaScript представляют собой объектный тип данных, служащий для хранения и обработки множества значений (чаще всего одного типа данных). Использование массивов в некоторых сценариях позволяет сделать код более компактным, в первую очередь благодаря сокращению количества объявляемых переменных.</p>

<p>Для наглядности, рассмотрим пример: пусть в скрипте реализована функция, которая возвращает сообщение об ошибке по ее коду.</p>


<example>
<kw>var</kw> error_msg1 = <str>"несоответствие типа данных"</str>;
<kw>var</kw> error_msg2 = <str>"в пароле присутствуют недопустимые символы"</str>;
<kw>var</kw> error_msg3 = <str>"некорректный e-mail адрес"</str>;
<kw>var</kw> error_msg4 = <str>"неизвестная ошибка"</str>;

<kw>function</kw> getErrorMessage(errorCode) {
    <kw>switch</kw> (errorCode) {
        <kw>case</kw> 1:
            <kw>return</kw> error_msg1;
        <kw>case</kw> 2:
            <kw>return</kw> error_msg2;
        <kw>case</kw> 3:
            <kw>return</kw> error_msg3;
        <kw>default</kw>:
            <kw>return</kw> error_msg4;
    }
}
</example>
<p>Приведенный пример на первый взгляд не обладает особой избыточностью. Однако, что вы скажете, если вариантов сообщений будет не 4 а 20 или 50? Я думаю никому не улыбается перспектива писать 50 раз блок <code><kw>case</kw></code>. Избавиться от этой необходимости нам помогут именно массивы.
</p>

<p>Как и любой объектный тип данных, массивы создаются при помощи оператора <code><kw>new</kw></code>. Существует три варианта вызова конструктора <code>Array()</code>:
</p>
<example>
<kw>var</kw> a = <kw>new</kw> Array(); <comment>// создание пустого массива</comment>&#160;
<kw>var</kw> a = <kw>new</kw> Array(<i>length</i>); <comment>// создание массива из "length" неопределенных значений</comment>&#160;
<kw>var</kw> a = <kw>new</kw> Array(<i>item1</i>, <i>item2</i>, ...); <comment>// создание массива из заданных значений</comment>&#160;
</example>

<p>Элементы массива хранятся последовательно, причем, каждый элемент имеет свой <i>индекс</i> (номер по порядку). Нумерация элементов массивов в JavaScript начинается с нуля.
Для доступа к элементу массива используют имя массива и индекс элемента, записанный после имени в квадратных скобках:
</p>

<example>
a[<num>0</num>] = <num>2</num>;
b = a[<num>0</num>]*<num>2</num>;
</example>

<p>Вернемся к нашему примеру. Все сообщения об ошибках можно хранить в массиве. Таким образом, код ошибки будет соответствовать ее номеру (индексу) в массиве и функция <code>getErrorMessage()</code> в простейшем случае будет состоять всего лишь из одного оператора <code><kw>return</kw></code>. Перепишем предыдущий пример с использованием массивов:
</p>
<example>
<kw>var</kw> error_msg = <kw>new</kw> Array();
error_msg[0] = <str>"несоответствие типа данных"</str>;
error_msg[1] = <str>"в пароле присутствуют недопустимые символы"</str>;
error_msg[2] = <str>"некорректный e-mail адрес"</str>;
...
error_msg[20] = <str>"неизвестная ошибка"</str>;

<kw>function</kw> getErrorMessage(errorCode) {
    <kw>return</kw> error_msg[errorCode];
}
</example>

<p>Невооруженным глазом видно, что код функции стал во много раз проще и, что самое примечательное, не будет усложняться с увеличением количества сообщений об ошибке.
</p>

<h3>Свойства и методы массивов</h3>
<p>Ниже в таблице представлены свойства и методы массивов:
</p>

<table align="center" border="1" cellspacing="0" frame="box" rules="groups" style="margin-bottom: 10;">
	<tr>
		<th>Свойство</th>
		<th>Пояснение</th>
	</tr>
	<caption align="center" valign="bottom">Табл. 2.1. Свойства и методы массивов</caption>
	
	<colgroup style="width: 400; padding-left: 10;" />
	<colgroup style="width: 500; padding-left: 10; padding-bottom: 5;" />
	
	<tr>
		<td><code><i>array</i>.<b>length</b></code></td>
		<td>Длина (количество элементов) массива</td>
	</tr>
	<tr>
		<td><code><i>array</i>.<b>prototype</b></code></td>
		<td>Ссылка на прототип класса объекта. Это свойство позволяет добавлять в объекты новые методы. Работа со свойством "prototype" рассматривается ниже.</td>
	</tr>
	
	<tr>
		<th>Метод</th>
		<th>Пояснение</th>
	</tr>
	<tr>
		<td><code><i>array1</i>.<b>push</b>(<i>item1</i>[, <i>item2</i>[, ... ]])</code></td>
		<td>Добавляет элементы "item1, item2, ..." в конец массива.</td>
	</tr>
	<tr>
		<td><code><i>array1</i>.<b>pop</b>()</code></td>
		<td>Удаляет последний элемент из массива и возвращает его в качестве значения.</td>
	</tr>
	<tr>
		<td><code><i>array1</i>.<b>shift</b>()</code></td>
		<td>Удаляет первый элемент из массива и возвращает его в качестве значения.</td>
	</tr>
	<tr>
		<td><code><i>array</i>&#160;<i>array1</i>.<b>unshift</b>(<i>item1</i>[, <i>item2</i>[, ... ]])</code></td>
		<td>Добавляет элементы "item1, item2, ..." в начало массива и возвращает итоговый массив. Порядок следования новых элементов соответствует порядку их перечисления в списке аргументов.</td>
	</tr>
	<tr>
		<td><code><i>array</i>&#160;<i>array1</i>.<b>concat</b>(<i>item1</i>[, <i>item2</i>[, ... ]])</code></td>
		<td>Возвращает массив, полученный в результате конкатенации массива "array1" и всех переданных методу значений ("item1", "item2", ...).</td>
	</tr>
	<tr>
		<td><code><i>string</i>&#160;<i>array1</i>.<b>join</b>(<i>separator</i>)</code></td>
		<td>Возвращает строковое значение, состоящее из сцепленных элементов массива, разделенных указанным разделителем ("separator")</td>
	</tr>
	<tr>
		<td><code><i>array</i>&#160;<i>array1</i>.<b>slice</b>(<i>start</i>[, <i>end</i>])</code></td>
		<td>Возвращает фрагмент массива "array1" начиная от элемента с индексом "start" до элемента с индексом "end" не включая его. Если индекс "end" не указан, фрагмент продолжается до конца массива.</td>
	</tr>
	<tr>
		<td><code><i>array</i>&#160;<i>array1</i>.<b>splice</b>(<i>start</i>, <i>count</i>[, <i>newItem1</i>, <i>newItem2</i>, ...])</code></td>
		<td>Удаляет из массива указанное число элементов начиная с позиции "start". При необходимости, заменяет удаленные элементы новыми значениями. Возвращает удаленные элементы в виде массива.</td>
	</tr>
	<tr>
		<td><code><i>array1</i>.<b>sort</b>([<i>sortFunction</i>])</code></td>
		<td>Сортирует элементы массива. Параметр "sortFunction" может указывать функцию, с помощью которой производится сортировка массива. Если функция "sortFunction" опущена, то выполняется ASCII-сортировка по возрастанию</td>
	</tr>
	<tr>
		<td><code><i>array1</i>.<b>reverse</b>()</code></td>
		<td>Обращает порядок следования элементов в массиве.</td>
	</tr>
	
</table>

<tip start="Примечание">для использования методов <code>push()</code>, <code>pop()</code>, <code>shift()</code>, <code>unshift()</code> и <code>splice()</code> необходима поддержка браузером JavaScript версии 5.5. Эта поддержка реализована в браузере Netscape начиная с версии 4, а в Internet Explorer начиная с версии 5.5
</tip>

<h3>Работа с массивами</h3> 
<h5>Ввод массива с клавиатуры</h5>
<p>Для ввода массива с клавиатуры чаще всего используют цикл. Если количество элементов массива известно заранее, используют цикл <code><kw>for</kw></code>. В противном случае подойдет цикл с постусловием <code><kw>do</kw>...<kw>while</kw></code>. Приведем пример:
</p> 
<example>
<kw>var</kw> a = <kw>new</kw>&#160;<stdfunc>Array</stdfunc>();
<kw>var</kw> count = <num>10</num>;
<kw>for</kw> (<kw>var</kw> i=<num>0</num>; i&lt;count; i++)
    a[i]=<stdfunc>parseInt</stdfunc>(<stdfunc>prompt</stdfunc>(<str>"Введите целое число:"</str>, <str>""</str>));
<stdfunc>alert</stdfunc>(<str>"Массив: "</str>+a.join(<str>", "</str>)); <comment>// вывод массива </comment>
</example>

<p>В приведенном фрагменте кода массив выводится в виде строки, где элементы массива разделяются символами ", ". Если массив необходимо вывести поэлементно, то можно будет снова использовать цикл <code><kw>for</kw></code>, так как длина массива нам известна и возвращается свойством <code>length</code> объекта <code>Array()</code>.
</p>

<h5>Добавление элементов в массив</h5>
<p>Для добавления элементов в массив можно воспользоваться методами <code>push()</code> и <code>unshift()</code>. Метод <code>push()</code> добавляет элементы в конец массива, а метод <code>unshift()</code> - в начало. Рассмотрим пример применения этих методов:
</p>
<example>
<kw>var</kw> a = <kw>new</kw>&#160;<stdfunc>Array</stdfunc>(<num>1</num>,<num>2</num>,<num>3</num>);
<stdfunc>alert</stdfunc> (<str>"Исходный массив: "</str>+a.join(<str>", "</str>));
<kw>if</kw> (<stdfunc>confirm</stdfunc>(<str>"Добавить в начало?"</str>)) {
    a.unshift(<num>-2</num>,<num>-1</num>,<num>0</num>);
} 
else {
    a.push(<num>4</num>,<num>5</num>,<num>6</num>);
}
<stdfunc>alert</stdfunc> (<str>"Итоговый массив: "</str>+a.join(<str>", "</str>));
</example>

<p>Эти методы не позволяют добавить массив в массив. Для этих целей используйте метод <code>concat()</code>
</p>

<h5>Удаление элементов из массива</h5>
<p>Для удаления элементов из массива используйте методы <code>pop()</code> и <code>shift()</code>. Метод <code>pop()</code> удаляет последний элемент массива, а метод <code>shift()</code> - первый. Рассмотрим пример применения этих методов:
</p>
<example>
<kw>var</kw> a = <kw>new</kw>&#160;<stdfunc>Array</stdfunc>(<num>0</num>,<num>1</num>,<num>2</num>,<num>3</num>, <num>4</num>);
<stdfunc>alert</stdfunc> (<str>"Исходный массив: "</str>+a.join(<str>", "</str>));
<kw>if</kw> (<stdfunc>confirm</stdfunc>(<str>"Удалить первый?"</str>)) {
    a.shift();
} 
else {
    a.push();
}
<stdfunc>alert</stdfunc> (<str>"Итоговый массив: "</str>+a.join(<str>", "</str>));
</example>

<p>Для удаления элемента располагающегося не в начале или в конце массива можно использовать метод <code>splice()</code> со следующими параметрами: <code>splice(<i>index</i>, 1)</code>, где <i>index</i> - номер удаляемого элемента. Следующий пример демонстрирует удаление элемента с индексом "2":</p>
<example>
<kw>var</kw> a = <kw>new</kw>&#160;<stdfunc>Array</stdfunc>(<num>1</num>,<num>2</num>,<num>3</num>,<num>4</num>);
<stdfunc>alert</stdfunc> (<str>"Исходный массив: "</str>+a.join(<str>", "</str>));
a.splice (2,1);
<stdfunc>alert</stdfunc> (<str>"Итоговый массив: "</str>+a.join(<str>", "</str>));
</example>

<h5>Применение метода <code>sort()</code></h5>
<p>Метод <code>sort()</code>, как упоминалось выше, позволяет выполнить сортировку, т.е. упорядочивание, элементов массива по заданному критерию. По умолчанию метод <code>sort()</code> рассматривает элементы как строки и критерием считается порядок символов строки в соответствии с таблицей ASCII. Для реализации других критериев сортировки элементов вы должны будете написать функцию, которая определяет порядок сортировки и строится следующим образом:
</p>
<ul>
	<li>функция должна принимать два параметра (назовем их a1 и a2)</li>
	<li>в случае, если a1 &gt; a2, функция должна вернуть положительное значение</li>
	<li>в случае, если a1 &lt; a2, функция должна вернуть отрицательное значение</li>
	<li>в случае, если a1 == a2, функция должна вернуть 0.</li>
</ul>

<p>Рассмотрим вышесказанное на практике: необходимо ввести массив целых чисел и отсортировать его по возрастанию и убыванию значений элементов.
</p>
<example number="2.5" title="сортировка элементов массива методом 'sort()'" href="samples/sort.html">
<comment>// объявление и ввод массива</comment>&#160;
<kw>var</kw> a = <kw>new</kw>&#160;<stdfunc>Array</stdfunc>();
<kw>var</kw> count = <num>5</num>;
<kw>for</kw> (<kw>var</kw> i=<num>0</num>; i&lt;count; i++)
    a[i]=<stdfunc>parseInt</stdfunc>(<stdfunc>prompt</stdfunc>(<str>"Введите целое число:"</str>, <str>""</str>));
<stdfunc>alert</stdfunc>(<str>"Неотсортированный массив: "</str>+a.join(<str>", "</str>)); <comment>// вывод массива </comment>&#160;
a.sort();
<stdfunc>alert</stdfunc>(<str>"Строковая сортировка массива: "</str>+a.join(<str>", "</str>)); <comment>// вывод массива </comment>&#160;
a.sort(numUp);
<stdfunc>alert</stdfunc>(<str>"Числовая сортировка по возрастанию: "</str>+a.join(<str>", "</str>)); <comment>// вывод массива </comment>&#160;
a.sort(numDown);
<stdfunc>alert</stdfunc>(<str>"Числовая сортировка по убыванию: "</str>+a.join(<str>", "</str>)); <comment>// вывод массива </comment>&#160;

<comment>// функции сравнения элементов </comment>&#160;
<kw>function</kw> numUp(a1, a2) { <comment>// сортировка по возрастанию </comment>&#160;
    <kw>return</kw> a1-a2;
}
<kw>function</kw> numDown(a1, a2) { <comment>// сортировка по убыванию </comment>&#160;
    <kw>return</kw> a2-a1;
}
</example>
<tip start="Примечание">на самом деле, функцию для обратной сортировки массива можно было не писать. Достаточно отсортировать массив по возрастанию значений, а, затем, вызвать метод <code>reverse()</code> для получения обратного порядка следования элементов.
</tip>

<h5>Работа со свойством <code>prototype</code></h5>
<p>Свойство <code>prototype</code> позволяет добавить в готовый объект новое свойство или метод. Для того, чтобы лучше понять принципы работы с этим замечательным свойством рассмотрим пример реализации метода <code>max()</code> (поиск максимального элемента) в массиве: 
</p>

<example number="2.6" title="использование сойства 'prototype'" href="samples/max.html">
<kw>function</kw> array_max(){
    <kw>var</kw> i, max = <kw>this</kw>[<num>0</num>];
    <kw>for</kw> (i = <num>1</num>; i &lt; <kw>this.length</kw>; i++)
        <kw>if</kw> (max &lt; <kw>this</kw>[i])
            max = <kw>this</kw>[i];
    <kw>return</kw> max;
}
<highlight><stdfunc>Array</stdfunc>.prototype.max = array_max;</highlight>&#160;

<kw>var</kw> a = <kw>new</kw>&#160;<stdfunc>Array</stdfunc>();
<kw>var</kw> count = <num>5</num>;
<kw>for</kw> (<kw>var</kw> i=<num>0</num>; i&lt;count; i++)
    a[i]=<stdfunc>parseInt</stdfunc>(<stdfunc>prompt</stdfunc>(<str>"Введите целое число:"</str>, <str>""</str>));
<stdfunc>alert</stdfunc>(<str>"Массив: "</str>+a.join(<str>", "</str>)); <comment>// вывод массива </comment>&#160;
<stdfunc>alert</stdfunc>(<str>"Максимум: "</str>+<highlight>a.max()</highlight>); <comment>// вывод максимума </comment>&#160;
</example>

<p>В примере сначала описывается функция <code>array_max()</code>, определяющая максимум текущего массива, обращаясь к его свойствам и элементам посредством указателя <code><kw>this</kw></code>. Затем, строка <code><stdfunc>Array</stdfunc>.prototype.max = array_max;</code> добавляет метод <code>max()</code> в массив. Вызов метода <code>max()</code> осуществляется традиционным образом.
</p>

<h3>Многомерные массивы</h3>
<p>К сожалению, в JavaScript отсутствует стандартная реализация многомерных массивов (даже 2-мерных). Однако, этот печальный недостаток можно обойти, создав <i>массив массивов</i>. Для этого необходимо создать массив, а, затем, каждый элемент этого массива так же сделать массивом. Выглядит это примерно так:
</p>
<example>
<kw>var</kw> n=<num>3</num>, <comment>//количество строк</comment>&#160;
    m=<num>5</num>; <comment>//количество элементов в строке (столбцов)</comment>&#160;
<kw>var</kw> a = <kw>new</kw>&#160;<stdfunc>Array</stdfunc> ();
<kw>for</kw> (<kw>var</kw> i=<num>0</num>; i&lt;n; i++) {
    a[i] = <kw>new</kw>&#160;<stdfunc>Array</stdfunc> (); <comment>//каждый элемент массива тоже массив!</comment>&#160;
    <kw>for</kw> (<kw>var</kw> j=<num>0</num>; j&lt;m; j++) {
        a[i][j] = i*j;
    }
}
</example>

<p>В приведенном примере создается и заполняется двумерный массив. Таким же образом можно создать и массивы большей размерности (3,4,5 и т.д). Для перебора элементов многомерных массивов используются вложенные циклы. Количество вложенных циклов, как правило, определяется количеством измерений создаваемого массива. На практике редко применяются даже двумерные массивы, не говоря уже о массивах большей размерности.
</p>

<h3>Кое что об индексах...</h3>
<p>До сих пор говорилось, о том, что индекс элемента в массиве - целое число, определяющее порядковый номер элемента. На самом деле, индексом элемента в массиве может быть и уникальный в рамках одного массива строковый идентификатор (то есть строка!). Возникает вполне резонный вопрос - зачем это нужно? Если вдуматься, то использование строк в качестве идентификаторов элемента массива в ряде случаев оказывается полезным. Можно, например, хранить в массиве пароли пользователей, а индексами элементов считать имена пользователей:
</p>
<example>
<kw>var</kw> users = <kw>new</kw>&#160;<stdfunc>Array</stdfunc>();
users[<str>"admin"</str>] = <str>"qxpfr45d"</str>;
users[<str>"mama"</str>] = <str>"nf67r"</str>;
users[<str>"papa"</str>] = <str>"pwr12aa"</str>;
users[<str>"gosti"</str>] = <str>""</str>;

<kw>var</kw> l = prompt(<str>"Введите свой логин:"</str>, <str>"gosti"</str>);
<kw>var</kw> p = prompt(<str>"Введите свой пароль:"</str>, <str>""</str>);
<kw>if</kw> (p == users[l]) {
    <stdfunc>alert</stdfunc> (<str>"Привет!"</str>);
    <comment>//дальнейшие действия ...</comment>&#160;
}
<kw>else</kw> {
    <stdfunc>alert</stdfunc> (<str>"Неверный логин или пароль"</str>);
}
</example>

<p>С точки зрения клиентского сценария данный пример не представляет практического интереса. Любой желающий может просмотреть код скрипта, увидеть в нем логин и пароль и воспользоваться ими для входа на страницу. Однако, не стоит забывать, что JavaScript используется для написания не только  клиентских, но и серверных сценариев, код которых не посылается пользователю, а выполняется на сервере. В этом случае приведенный механизм защиты становится не таким уж и плохим. 
</p>
<p>К вопросу защиты страниц паролем мы еще вернемся ближе к концу курса JavaScript. В данном контексте пример приводится лишь в учебных целях.
</p>
</lesson>